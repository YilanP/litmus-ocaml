(* Assume Ast has a function to_string : s -> string for converting parsed results to string *)
open Ast
open Parser
open Lexing

(* Describes a token generated by the lexer for debugging purposes *)
let describe_token = function
  | LBRACE -> "LBRACE"
  | RBRACE -> "RBRACE"
  | QUOTE -> "QUOTE"
  | LET -> "LET"
  | R -> "R"
  | P -> "P"
  | EQUAL -> "EQUAL"
  | EXISTS -> "EXISTS"
  | LPAREN -> "LPAREN"
  | RPAREN -> "RPAREN"
  | AND -> "AND"
  | OR -> "OR"
  | ARCH s -> Printf.sprintf "ARCH(%s)" s
  | NUMBER n -> Printf.sprintf "NUMBER(%d)" n
  | STRING s -> Printf.sprintf "STRING(%s)" s
  | EOF -> "EOF"
  | _ -> "Unknown Token"  (* Handle unexpected cases, though all should be covered *)

let () =
  let lexbuf = Lexing.from_channel stdin in
  try
    while true do
      let token = Lexer.token lexbuf in
      let start_pos = Lexing.lexeme_start lexbuf in
      let end_pos = Lexing.lexeme_end lexbuf in
      Printf.printf "Token: %s (start: %d, end: %d)\n" (describe_token token) start_pos end_pos;
      if token = Parser.EOF then exit 0  (* Stop processing at EOF *)
    done
  with
  | Lexer.Error msg ->
      Printf.fprintf stderr "Lexer error: %s\n%!" msg
  | Parser.Error ->
      Printf.fprintf stderr "Parser error at offset %d: syntax error.\n%!" (Lexing.lexeme_start lexbuf)
  | Failure msg ->
      Printf.fprintf stderr "Error: %s\n%!" msg
